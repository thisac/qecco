import time
import warnings
from datetime import date, timedelta, datetime
from pathlib import Path
import sys
import json
# import warnings

import bosonic as b
import numpy as np

from .. import utils as u
from ..utils import timeit
from .state_set_optimization import optimize_state_set_lossless as opt
from .state_set_optimization import get_num_phases
from .encoding import Encoding
from qecco.utils import print_array as pa

# warnings.simplefilter(action='ignore', category=FutureWarning)


class System:
    """ Parameters and functions for a system; encoder/decoder

    Functions to load, build, update system, and getting ouput and data. Easily
    accessible to a user.

    Attributes:
        system_types (str): defines what type of system it is: e.g.encoder,
            decoder
        running (boo): whether optimization is currently running in the
            backround (True) or not (False)
        paramters (dict): dictionary with all parameters input by user or
            generated by object
        encoding (encoding obj): object for holding density matrices and fock
            basis encodings, including altering functions
        results (dict): the results from a finished optimization
        loss_functions (dict): the different loss functions that can be used
            by the optimization
    """

    def __init__(self, system_type, parameters=None):
        self.system_type = system_type
        self.running = False
        self.parameters = parameters
        self.encoding = Encoding()

        self.results = None

        self.loss_functions = {
            "bosonic_density_loss": b.density.apply_density_loss,
        }

        self._set_parameters(self.parameters, set_default=True)

    def _set_parameters(self, new_parameters, set_default=False, print_parameters=True):
        """Set all parameters for object

        Either set to default values or to corresponding values in
        new_parameters dict. Also sets/updates parameters to the self.encoding
        object.

        Parameters:
            new_parameters (dict): parameter to be set, i.e. changed, in
                self.parameters.
            set_default (bool): reset all parameters to default values before
                setting the new_parameters (true) or keep the old parameters
                and only change the corresponding ones in the new_parameters
                dictionary (false).
            print_parameters (bool): whether to print the new parameters again
                (True) or not (False) after running
        """
        if new_parameters is None:
            new_parameters = {}

        if set_default:
            loaded_parameters = self.load_parameters()
            loaded_parameters.update(new_parameters)
            new_parameters = loaded_parameters
            default_parameters = {}
        else:
            if self.parameters is None:
                self.parameters = {}
            else:
                default_parameters = self.parameters

        valid_parameters = [
            "num_of_layers", "num_of_tests", "opt_algorithm", "method",
            "simple_cost", "loss_function", "loss_kwargs", "phi",
            "num_of_evaluations", "ancillae", "n_photons", "m_modes",
            "code_name", "gen_encoder_inputs", "print_every", "verbose",
            "save_data", "data_in_lossy_basis", "photonic", "pulse_sequence",
            "fock_basis_length", "m_ancillae", "n_ancillae", "num_phases",
            "etas", "full_loss", "save_name", "save_folder",
            "use_last_layer_as_guess",
            ]

        for key, value in new_parameters.items():
            if key not in valid_parameters:
                raise ValueError(f"{key} is not a valid parameter")
            else:
                default_parameters[key] = value

        self.parameters = default_parameters

        # If num_of_layers is an int, transform it into a list
        if isinstance(self.parameters["num_of_layers"], int):
            self.parameters["num_of_layers"] = [self.parameters["num_of_layers"]]

        # If phi is in an ndarray, take it out.
        try:
            self.parameters["phi"] = self.parameters["phi"].item()
        except AttributeError:
            pass

        self.parameters["n_photons"] = int(self.parameters["n_photons"])
        self.parameters["m_modes"] = int(self.parameters["m_modes"])
        n_an = int(self.parameters["n_photons"] + np.sum(self.parameters["ancillae"]))
        m_an = int(self.parameters["m_modes"] + len(self.parameters["ancillae"]))

        N = len(b.fock.basis(n_an, m_an))

        more_parameters = {
            "n_ancillae": n_an,
            "m_ancillae": m_an,
            "fock_basis_length": N,
            }

        self.parameters.update(more_parameters)
        self.encoding.set_parameters({
            "n_photons": self.parameters["n_photons"],
            "m_modes": self.parameters["m_modes"],
            "ancillae": self.parameters["ancillae"],
            "simple_cost": self.parameters["simple_cost"],
            })

        if self.parameters["verbose"]:
            if print_parameters is True:
                self.print_parameters()
        else:
            self.parameters["print_every"] = None

    def print_parameters(self):
        """ Print parameters of system """
        print("\nParameters:")
        u.print_dict(self.parameters)
        print("\n")

    def load_parameters(self):
        """ Load parameters from a local JSON file """
        codes = None
        custom_code_path = Path.cwd() / "parameters.json"
        script_path = Path(__file__).parent / "parameters.json"
        try:
            with open(custom_code_path) as read_file:
                codes = json.load(read_file)[self.system_type]
        except FileNotFoundError:
            pass
        except KeyError:
            warnings.warn(f"System parameters for {self.system_type} not found in custom directory", Warning)

        try:
            with open(script_path) as read_file:
                codes = json.load(read_file)[self.system_type]
        except KeyError:
            warnings.warn(f"System parameters for {self.system_type} not found in default directory", Warning)

        return codes

    def optimize(self, **kwargs):
        """ Optimize the system

        Parameters:
            kwargs: used as inputs into the nlopt optimization, if needed.
        """
        if self.parameters["save_data"]:
            try:
                data_folder = Path("data") / date.today().strftime("%Y%m%d") / str(self.parameters["save_folder"])
            except KeyError:
                data_folder = Path("data") / date.today().strftime("%Y%m%d")
            if data_folder.exists():
                print(f"Warning: {data_folder} exists. Data may be overwritten!")
                input("Press Enter to continue...")
            else:
                data_folder.mkdir(parents=True)

        # Backup previous parameter folder (if it exists) as "parameters (old)"
        # and save the new parameters as "parameters".
        if self.parameters["save_data"]:
            save_path = data_folder / "parameters"
            save_path_old = data_folder / "parameters (old)"
            if save_path.exists():
                if save_path_old.exists():
                    u.remove(save_path_old)
                save_path.rename(save_path_old)
            u.save_dict(save_path, self.parameters, suppress_warning=True)

        t_start = time.perf_counter()
        if self.parameters["verbose"]:
            print("\nTime-counter started at: {}".format(datetime.now()))

        all_results = []
        results = None
        try:
            kwargs_guess = kwargs["guess"].copy()
        except (AttributeError, KeyError):
            kwargs_guess = None
        for i, layers in enumerate(self.parameters["num_of_layers"]):
            t_layer = time.perf_counter()
            if self.parameters["verbose"]:
                print("\nAncillae: {}".format(self.parameters["ancillae"]))
                print("---------------------------------------------------")
                print("| Photons: {}  Modes: {}  Layers: {:3d}  -- {:3d} / {:3d} |".format(self.parameters["n_ancillae"], self.parameters["m_ancillae"], layers, i + 1, len(self.parameters["num_of_layers"])))
                print("---------------------------------------------------\n")

            # Backup previous data folder (if it exists).
            if self.parameters["save_data"]:
                try:
                    save_path = data_folder / f"{layers:03d}_layers"
                    save_path_old = data_folder / f"{layers:03d}_layers (old)"
                except (KeyError, TypeError):
                    save_path = data_folder / f"{layers:03d}_layers"
                    save_path_old = data_folder / f"{layers:03d}_layers (old)"
                if save_path.exists():
                    if save_path_old.exists():
                        u.remove(save_path_old)
                    save_path.rename(save_path_old)

            best_error = 1
            best_idx = 0
            best_num_of_evals = None

            if self.parameters["use_last_layer_as_guess"] and i != 0:
                num_phases = get_num_phases(self, layers, return_val=True)
                if num_phases < len(results["bestX"]):
                    kwargs["guess"] = results["bestX"][:num_phases]
                else:
                    diff = num_phases - len(results["bestX"])
                    kwargs["guess"] = np.pad(results["bestX"], (0, diff), constant_values=1)

            elif kwargs_guess is not None:
                kwargs["guess"] = kwargs_guess[i]

            if self.parameters["num_of_tests"] == 0:
                num_of_tests = 999999
                stop_at_minimum = True
            else:
                num_of_tests = self.parameters["num_of_tests"]
                stop_at_minimum = False
            for j in range(num_of_tests):

                results = opt(
                    self.encoding,
                    numLayers=layers,
                    system_list=[self],
                    **kwargs,
                    )

                # Save the results in separate folders.
                if self.parameters["save_data"]:
                    u.save_dict(save_path / f"run_{j:03d}", results, suppress_warning=True)

                if results["bestError"] < best_error:
                    best_idx = j
                    best_error = results["bestError"]
                    best_num_of_evals = results["numEvaluations"]
                    best_results = results.copy()

                if self.parameters["verbose"]:
                    print("{:3d}  {:>15}    Min error: {:.2e}\n".format(j, results['returnCodeMessage'], results["bestError"]))

                if stop_at_minimum and best_error < 1e-8:
                    num_of_tests = j + 1
                    break
            all_results.append(best_results)
            if self.parameters["save_data"]:
                pre_best_path = save_path / f"run_{best_idx:03d}"
                post_best_path = save_path / f"run_{best_idx:03d} (best)"
                pre_best_path.rename(post_best_path)

            t_mid = time.perf_counter()
            if self.parameters["verbose"]:
                print("\nMid-time:        {}".format(datetime.now()))
                print("\nTime per test:   {}".format(timedelta(seconds=((t_mid - t_layer) / num_of_tests))))
                print("Runtime [h:m:s]: {}".format(timedelta(seconds=(t_mid - t_start))))
                print("\nMinimum error: {}".format(best_error))
                print("\n# of evaluations: {}\n".format(best_num_of_evals))

        t_stop = time.perf_counter()

        if self.parameters["verbose"]:
            print("Total runtime [h:m:s]: {}".format(timedelta(seconds=(t_stop - t_start))))

        if len(all_results) == 1: all_results = all_results[0]
        self.results = all_results

    def build_codes(self, code_name=None):
        """Wrapper for the build_bosonic_codes function in the encoding object

        Parameters:
            code_name (str): which code set to load. If none, then load default
                code set.
        """
        if code_name is None:
            code_name = self.parameters["code_name"]
        self.encoding.build_bosonic_codes(code_name, gen_encoder_inputs=self.parameters["gen_encoder_inputs"])
        if self.parameters["verbose"]:
            print("Bosonic codes are ready!")

        # If the number of photons, modes or ancillae has changed in encoder,
        # then update parameters accordingly.
        self._set_parameters({
            "n_photons": self.encoding.n_photons,
            "m_modes": self.encoding.m_modes,
            "ancillae": self.encoding.ancillae,
            },
            print_parameters=False)
        return self

    def build_rhos(self):
        """Translates the bosonic codes into density matrices

        If no codes (in the pure states) are loaded/built, then load/build them
        first. Transform the pure state codes into density matrices.
        """
        if self.parameters["verbose"]:
            print("Converting codes to density matrices...")
        if self.encoding.bc_inputs is None \
                or self.encoding.bc_targets is None:
            self.build_codes()

        self.encoding.pure_to_rho(gen_encoder_inputs=self.parameters["gen_encoder_inputs"])

        if self.parameters["verbose"]:
            print("Density matrices are ready!")
        return self

    # @timeit
    def apply_loss(self, rho=None, verbose=True, loss_function=None, **loss_kwargs):
        """Wrapper for the apply loss functions in the encoding object

        I a single rho is provided, then call the apply_loss_to_single_rho in
        the encoding object, otherwise use the systems rho_targets to apply
        loss through the apply_loss_to_rhos function in the encoding object.

        Parameters:
            rho [[complex]]: a target density matrix to apply loss to, if None
                then apply loss to all the systems target density matrices
            verbose (bool): whether to print anything (True) or be quiet
                (False)
            loss_function (function): the function to be used to apply loss
            loss_kwargs (dict): parameters to be used by the loss function
        """
        if loss_function is None:
            if self.parameters["verbose"] and verbose:
                print("Using default loss type")
            loss_function = self.loss_functions[str(self.parameters["loss_function"])]
            loss_kwargs = self.parameters["loss_kwargs"]
            print(loss_kwargs)
            print(loss_kwargs["n"])

        if rho is not None:
            rho_lossy = self.encoding.apply_loss_to_single_rho(
                rho,
                loss_function=loss_function,
                **loss_kwargs,
                )
            return rho_lossy
        else:
            if self.encoding.rhos_targets is None:
                raise TypeError("must generate rhos before applying loss.")
            else:
                self.encoding.apply_loss_to_rhos(
                    loss_function=loss_function,
                    **loss_kwargs,
                    )
                if self.parameters["verbose"]:
                    print("Applying loss... the rhos are lossy!")
        return self

    def remove_loss(self):
        """Remove the lossy density matrices"""
        if self.rhos['lossy'] is not None:
            self.encoding.rhos_lossy = None
            if self.parameters["verbose"]:
                print("The lost photons are back!")
        return self

    def update_parameters(self, parameters, set_default=False, print_parameters=True):
        """ Update parameters in System

        Parameters:
            parameters (dict): the new parameters to set
            set_default (bool): whether to set the other parameter back to
                their default values (True) or keep them as they are (False)
        """
        self.encoding.reset()
        self._set_parameters(parameters, set_default, print_parameters)
        return self

    def update_targets(self, new_targets):
        """Update the target density matrices

        Parameters:
        new_targets ([[[complex]]]): the set of all target density matrices
            (each [[complex]]) to be set as new targets.
        """
        self.encoding.update_targets(new_targets)

    def get_output(self, x=None):
        """Get outputs from system based on the density matrix inputs

        Parameters:
            x ([float]): the theta values for the unitary system matrix to be
                used to build the system and calulate the ouput density matrix

        Returns ([[[complex]]]): ouput from applying the system unitary matrix
            to the system inputs
        """
        if x is None:
            try:
                x = self.results["bestX"]
            except TypeError as e:
                raise TypeError(
                    "No prior results to use. "
                    f"Supply thetas or optimize {self.system_type} first."
                    ) from e

        if self.encoding.rhos_inputs is not None:
            build_system, _ = b.qonn.build_system_function(
                self.parameters["n_ancillae"],
                self.parameters["m_ancillae"],
                self.parameters["num_of_layers"][0],
                phi=self.parameters["phi"],
                method=self.parameters["method"],
                lossy=True,
                )

            S = build_system(x)
            SH = np.conj(S.T)

            rhos_out = []
            for rho in self.encoding.rhos_inputs:
                rho_tmp = np.dot(np.dot(S, rho), SH)

                rho_tmp = self.encoding.lossless_to_targets(rho_tmp)
                rhos_out.append(rho_tmp)

            return rhos_out

        else:
            raise NotImplementedError("No valid outputs")

    def status(self):
        """Prints the status of the system"""
        print("######## System object ########")
        print(f"System: {self.system_type}")
        print(f"Simple cost: {self.parameters['simple_cost']}")
        print(f"Is running: {self.running}")
        has_inputs = self.encoding.bc_inputs is not None
        has_targets = self.encoding.bc_targets is not None
        print(f"Has bosonic codes: {has_inputs and has_targets}")
        print(f"Has rhos: {self.encoding.rhos_targets is not None}")
        print(f"Has loss: {self.encoding.rhos_lossy is not None}")

        if self.encoding.rhos_lossy is not None:
            print(f"Loss function: {self.parameters['loss_function']}")
            for key, value in self.parameters["loss_kwargs"].items():
                print(f"    {key}: {value}")
        print("################################")
